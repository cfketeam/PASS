#'
#'generate the simulation data
#'
#'
#' @param p The number of predictors of interest.
#' @param family The distribution of the simulated data: "binomial" for logistic regression model and "cox" for Cox proportional hazards regression model.
#' @param k The number of nonzero coefficients in the underlying regression model.
#' @param rho A parameter used to characterize the pairwise correlation between predictors. Default is 0.
#' @param sigma A parameter used to control the signal-to-noise ratio. For logistic regression and Cox model, the larger the value of sigma, the higher the signal-to-noise ratio.
#' @param beta The coefficient values in the underlying regression model.
#' @param censoring Whether data is censored or not. Only necessary if ' family ' is of class 'cox'; otherwise ignored. Default is TRUE.
#' @param c The censoring rate. Only necessary if ' family ' is of class 'cox'; otherwise ignored. Default is 1.
#' @param scal A parameter in generating survival time based on the Weibull distribution. Only necessary if ' family ' is of class 'cox'; otherwise ignored. Default is 1.
#' @param alpha A parameter in generating disturbances controlling the prediction performance underlying the nonzero coefficients.
#'
#'\details{We generated the design matrix \bar{X} and the underlying coefficients Î² as follows. The design matrix X was generated with X_j = \bar{X}_j + rho(\bar{X}_{j+1}+\bar{X}_{j-1})
#'For logistic regression, the binary response was generated by
#'Prob(Y = 1) = exp(X beta + delta)/(1 + exp(X beta + delta))
#'The ranges of nonzero coefficients were set as[4b,8b], b=5sigma sqrt{2log(p)/n}, The disturbance delta was subjected to a normal distribution delta \sim N(0,alpha^2).
#'For Cox regression, we generated data with hazard rate
#'T = (-log(S(t))/exp(X beta + delta))^(1/scal)
#'The ranges of nonzero coefficients were set the same as those in logistic regression, set as[4b,7b], b=5sigma sqrt{2log(p)/n}, the disturbance delta was subjected to a normal distribution delta \sim N(0,alpha^2).
#'%%  ~~ If necessary, more details than the description above ~~
#'}
#'
#' @return
#' @returns x:     The Design matrix of predictors.
#' @returns y     Response variable.
#' @returns Tbeta The coefficients used in the underlying regression model.
#' @export
#'
#'
#' @examples
#' k <-10
#' sigma <- 1
#' rho <- 0.5
#' a <- simu.data(n=200,p=1000,family = "binomial", k, rho, sigma,alpha=4)
#'

simu.data <- function (n, p, family, k, rho = 0, sigma = 1, beta = NULL, censoring = TRUE,
                  c = 1, scal, alpha=4)
{
  one = rep(1, n)
  zero = rep(0, n)
  X = rnorm(n * p)
  X = matrix(X, n, p)
  X = scale(X, TRUE, FALSE)
  normX = sqrt(drop(one %*% (X^2)))
  X = sqrt(n) * scale(X, FALSE, normX)
  gc()
  x = X + rho * (cbind(zero, X[, 1:(p - 2)], zero) + cbind(zero,
                                                           X[, 3:p], zero))
  colnames(x) = paste0("X", 1:ncol(x))
  rm(X)
  gc()
  nonzero = sample(1:p, k)
  Tbeta = rep(0, p)
  if (family == "gaussian") {
    m = 5 * sqrt(2 * log(p)/n)
    M = 100 * m
    if (is.null(beta))
      Tbeta[nonzero] = runif(k, m, M)
    else Tbeta = beta
    y = drop(x %*% Tbeta + rnorm(n, 0, sigma^2))
    return(list(x = x, y = y, Tbeta = Tbeta))
  }
  if (family == "binomial") {
    m = 5 * sigma * sqrt(2 * log(p)/n)
    if (is.null(beta))
      Tbeta[nonzero] = runif(k, 4 * m, 8 * m)
    else Tbeta = beta
    ex = exp(drop(x %*% Tbeta + rnorm(n, 0, alpha^2)))
    logit = ex/(1 + ex)
    y = rbinom(n = n, size = 1, prob = logit)
    return(list(x = x, y = y, Tbeta = Tbeta))
  }
  if (family == "cox") {
    m = 5 * sigma * sqrt(2 * log(p)/n)
    if (is.null(beta))
      Tbeta[nonzero] = runif(k, 4 * m, 7 * m)
    else Tbeta = beta
    time = (-log(runif(n))/drop(exp(x %*% Tbeta + rnorm(n, 0, alpha^2))))^(1/scal)
    if (censoring) {
      ctime = c * runif(n)
      status = (time < ctime) * 1
      censoringrate = 1 - sum(status)/n
      cat("censoring rate:", censoringrate, "\n")
      time = pmin(time, ctime)
    }
    else {
      status = rep(1, times = n)
      cat("no censoring", "\n")
    }
    return(list(x = x, y = cbind(time, status), Tbeta = Tbeta))
  }
}


